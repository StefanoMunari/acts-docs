\subsection{Viewer}

The viewer exploits several networking paradigms to communicate with the
Application Server:

\begin{itemize}
  \item \textbf{Push model:} used to efficiently receive realtime data from
    the Application Server; in particular, we decided to employ WebSockets
    for this purpose;
  \item \textbf{Pull model:} used for requesting static data to the
    Application Server by means of REST calls.
\end{itemize}

Our viewer leverages OOP to have a solid structure which resembles the
architecture of our application layer (with respect to infrastructural
entities and travelers). This is the simple reason why we will not dig into
the details for the frontend architecture, since we would have to repeat the
same description we already provided in Section \ref{sec:sol-des-app-layer}
when talking about the application layer design.

\paragraph{Note}
Since we wanted the simulation to look more fluent, the viewer applies further delays to the traveler's movements (otherwise it would be jerkily).
Therefore, there could be visual inconsistencies which do not reflect what happens under the hood: like vehicles engaging a crossing even if the traffic light is red, though in the backend the simulation does not produce errors.