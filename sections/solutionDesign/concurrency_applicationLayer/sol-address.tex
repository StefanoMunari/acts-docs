%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CONCURRENCY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Solution to Concurrency Problems}

Our solution addresses the problems we pointed out in section
\ref{sec:pa-concurrency}. Therefore here we are providing answers to the
questions we made ourselves at the beginning of the development.

\paragraph{How can we recognize that a situation is suitable to present
concurrency?}
There are several active entities in our application: pedestrians, cars, bikes
and buses. They act because of their own initiative, so they are likely to be
considered as active tasks.

Moreover, their actions cause side-effects to reactive entities like roads.
Consequently, our application needs to embody concurrency, i.e., potential
parallelism.

\paragraph{How concurrent accesses will be managed? Will it make sense to
discern side-effect accesses (procedures) from read-only accesses
(\textit{functions})?}
Concurrent accesses will be managed by means of \textit{Protected Objects},
i.e. resources that can be accessed in concurrent read
\textbf{or} mutual exclusive write mode.

It indeed makes sense to have the mentioned separation.
It may be useful to modify roads' status when vehicles travel through them.
Furthermore it might be useful to get information from them
when someone asks for it without causing side-effects.

\paragraph{Which entities have to be active?}
In light of active entities undertake spontaneous actions, in our context they
are:
\begin{itemize}
  \item Moving entities, which move around the city according to their own will;
  \item Semaphores, which autonomously change their color by the time elapses.
\end{itemize}

\paragraph{Which entities have to be reactive?}
Roads (with all their parts) and crossroads should be reactive entities:
\begin{itemize}
  \item A road is used to travel towards a destination and it takes actions
    only when it is trod.
    However, the state of a road is composed of the states of the reactive
    sub-entities it comprises, e.g., stretches and houses;
  \item A crossroads coordinates the traffic at road intersections exclusively
    whenever a moving entity requires to cross it.
\end{itemize}

\paragraph{Which entities have to be passive?}
Passive entities are stateless. Therefore, road signs fit perfectly in this
definition, since they represent immutable information that is read by road
users.

\paragraph{Should we use any formal technique to proof the correctness
of the system properties relating to concurrence?}
We will strive to motivate the correctness of our application but we
deliberately do not choose any specific technique.

\paragraph{Do we have the possibility to incur a non-valid state?
If so, how do we handle the problem?}
The application will be designed to avoid non-valid states. However, if the
system recognizes it is in a non-valid state, it resumes the execution from the
last valid snapshot.
% resumes: see https://www.cs.york.ac.uk/rts/books/RTSbookThirdEdition/chap6.pdf

\paragraph{How can we avoid possible starvation scenarios?}
The application will be designed to overcome starvation or deadlock scenarios.
In fact, active entities do not hold resources.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% APPLICATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Solution to Application Problems}

In section \ref{sec:pa-app-problems} some problems inherently related to the
application domain are explained, and our solution design is thought to solve
them.

\paragraph{Pedestrian Deadlock}
This problem will be avoided ``by design'' by organizing sidewalks in
\textit{lanes}. Though sidewalks in real world usually do not have lanes (apart
from seldom exceptions), we employ the concept of a \textit{logic} lane, i.e.
an abstraction that allows us to coordinate opposite flows of pedestrians in an
agile way.

Since pedestrians proceeding in opposite directions will not compete to enter
the same sidewalk stretch, there can not be any pedestrian deadlock.

\paragraph{Rear-end Collisions}
If the next road stretch of a moving entity route is already taken, the entity
will wait for the stretch to become free before moving on.

\paragraph{Stretch Parallelism}
One road stretch (e.g., a sidewalk stetch) may contain more than one entity of
the same type (e.g., pedestrians) at a time.
Parallelism is achieved by using a system of worker threads thanks to which
more than one active entity can potentially act in parallel in a district.

\paragraph{Yield rules}
The logic to manage yield rules will be encapsulated in crossroads, which has
to ensure the respect of the street code.

\paragraph{Booking a park spot}
A traveller which is going out of a building with a vehicle will try to book
beforehand a spot in the destination building garage, so that when she'll
arrives at destination she will find room to park her vehicle.

Even if this may not seem a concurrency problem at first glance, it is indeed:
two travellers may be leaving from each other's destination, and try to book a
spot in the garages they are leaving.
Therefore, if they both retain a lock on the garage to hold the vehicle they
are coming out with, they are exposed to a deadlock hazard.

We address this issue by making the garage implementation thread-safe, namely
having it be composed of three protected objects:

\begin{itemize}
  \item \textbf{Parked vehicles:} vehicles which are parked in the garage
    without anyone onboard
  \item \textbf{Leaving vehicles:} vehicles which are currently exiting the
    garage
  \item \textbf{Pending vehicles:} vehicles which are not yet arrived in the
    garage
\end{itemize}

Thanks to this division, we are able to avoid holding a lock on the garage
object and access its state concurrently without blocking inside the critical
regions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TIME
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Solution to Time Problems}

In section \ref{sec:pa-time-problems} we point out some questions we made
ourselves about time management in our simulations; hereafter we provide
answers on how we designed the flow of time in our system.

\paragraph{How can we simulate road users proceeding (regarding to travelling
  speed)?}
Our system will be comprehensive of a scheduler, which executes actions
according to an internal agenda.
This agenda is a priority queue in which each entry is matched to a specific
logic instant in time, during which a list of actions has to be executed. This
means active entities will conform to a common interface through which the
scheduler can make them run.

When all the actions for a specific time instant will be executed, the
scheduler will notify other nodes and will wait for a signal (called
\textbf{tick}) to start processing the next entry of its agenda.

%TODO: A cool figure which depicts a scheduler's agenda sample

We will make some speed ranges correspond to a given deferral, so that
travellers with different speeds will take more time to tread stretches with
the same length. For example, a pedestrian might take $25$ logical instants to
move from the beginning to the end of a stretch, whereas a car could take only
$2$ instants to travel the same distance.

We made this choice so that, in the case of a simulation running on several
nodes, our system is far less susceptible to time drift.

\paragraph{How can we simulate crossroads (regarding to road users' arrivals
  time)?}
Crossroads logic will be managed by means of an Ada Protected Object. By
carefully handling concurrent accesses to these objects, we aim to provide the
exact semantic for intersections between roads.

\paragraph{How long do people stay in facilities for? How much precise do these
  intervals have to be?}
Time spent in facilities is decided arbitrarily as a configuration parameter.
These time periods will have the best accuracy provided by the resolution
chosen for the scheduler.

\paragraph{How are semaphores going to be able to synchronize? Which of them
  decide how much time do they have to wait for?}
Semaphores will be active entities, and therefore their actions will be
periodically scheduled.

The period of a semaphore will be a configuration parameter.

\paragraph{When is it suitable to use logical clocks instead of local system
  clock?}
As for our simulations, logical time will be used for nearly everything so that
our application will not suffer to drift caused by computation on different
nodes.

However, we will seldom rely on wall clock time for specific operations, like
request timeouts for RPCs.
