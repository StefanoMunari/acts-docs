%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CONCURRENCY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Solution to Concurrency Problems}

Our solution addresses the problems we pointed out in section
\ref{sec:pa-concurrency}.
Therefore here we are providing details on how we tackled the questions we
made ourselves at the beginning of the development.

\paragraph{How can we recognize that a situation is suitable to present
concurrency?}
There are several active entities in our application: pedestrians, cars, bikes
and buses. They act because of their own initiative, so they are likely to be
considered as active tasks.

Moreover, their actions cause side-effects to reactive entities like roads.
Consequently our application needs to embody concurrency, i.e., potential
parallelism.

\paragraph{How concurrent accesses will be managed? Will it make sense to
discern side-effect accesses (procedures) from read-only accesses
(\textit{functions})?}
Concurrent accesses will be managed by means of \textit{Protected Objects},
i.e., resources that can be accessed in concurrent read \textbf{or} mutual
exclusive write mode.

It indeed makes sense to have the mentioned separation.
It may be useful to modify roads' status when vehicles travel over them.
On the other hand, it might be useful to get information from them when
someone asks for it without causing side-effects, and this should be doable in
parallel.

\paragraph{Which entities have to be active?}
In light of the fact that active entities undertake spontaneous actions, in
our context they are:
\begin{itemize}
  \item Moving entities, which move around the city according to their own
    will;
  \item Semaphores, which autonomously change their color by the time elapses.
\end{itemize}

\paragraph{Which entities have to be reactive?}
Streets (and all their parts) and crossroads should be reactive entities:
\begin{itemize}
  \item A street is used to travel towards a destination and it is used only
    when it is trod.
    However, the state of a road is composed of the states of the reactive
    sub-entities it comprises, e.g., stretches and houses;
  \item A crossroads coordinates the traffic at street intersections
    exclusively whenever a moving entity requires to cross it.
\end{itemize}

\paragraph{Which entities have to be passive?}
Passive entities are stateless. Therefore, road signs fit perfectly in this
definition, since they represent immutable information that is read by road
users.

\paragraph{Should we use any formal technique to proof the correctness
of the system properties relating to concurrence?}
We will strive to motivate the correctness of our application but we
deliberately do not choose any specific technique.
We did some concurrent tests, that is scheduling tests. In these tests we prove
that executors can start, distribute work across several worker threads and
stop gracefully.

\paragraph{Do we have the possibility to incur a non-valid state?
If so, how do we handle the problem?}
The application will be designed to avoid non-valid states.
However, if the system recognizes it is in a non-valid state, it resumes the
execution from the last valid snapshot.
% resumes: see https://www.cs.york.ac.uk/rts/books/RTSbookThirdEdition/chap6.pdf

\paragraph{How can we avoid possible starvation scenarios?}
The application will be designed to overcome starvation or deadlock scenarios.

In fact, active entities do not hold locks on protected objects and do not
block on RPCs: while the first condition is quite easy to achieve (the
compiler came in to give us a hand), the latter has been not straightforward
to implement.

We designed an event loop which resembles the one present in NodeJS: when
performing an RPC, a worker thread will provide a couple of callbacks (one for
the success case and the other for the failure case): after having instantiated
these callbacks, the thread will be free to execute other active entities,
without awaiting the response.
Clearly, since Ada does not provide enhanced support for closures, we had to
find a way to obtain the same semantics. We did so by defining an interface
\texttt{Callback}, which exposes a single operation, \texttt{Execute} (which
in turn takes no parameters). At this point we just have to concretize
\texttt{Callback} with an appropriate behaviour (e.g., an example of this can
be found in \texttt{Scheduling.Remote.Callback.Success.Tread}).
Actually, the hierarchy we set up is a bit different, since we also added two
intermediate interfaces \texttt{Callback.Success} and
\texttt{Callback.Failure}, in order to use strong typing for pairs of
callbacks.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% APPLICATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Solution to Application Problems}

In section \ref{sec:pa-app-problems} some problems inherently related to the
application domain are explained, and our solution design is thought to solve
them.

\paragraph{Pedestrian Deadlock}
This problem will be avoided ``by design'' by organizing sidewalks in
\textit{lanes}. Though sidewalks in real world usually do not have lanes (apart
from seldom exceptions), we employ the concept of a \textit{logic} lane, i.e.
an abstraction that allows us to coordinate opposite flows of pedestrians in an
agile way.

Since pedestrians proceeding in opposite directions will not compete to enter
the same sidewalk stretch, there can not be any pedestrian deadlock.

\paragraph{Rear-end Collisions}
If the next road stretch of a moving entity route is already taken, the entity
will wait for the stretch to become free before moving on.

\paragraph{Stretch Parallelism}
One road stretch (e.g., a sidewalk stetch) may contain more than one entity of
the same type (e.g., pedestrians) at a time.
Parallelism is achieved by using a system of worker threads thanks to which
more than one active entity can potentially act in parallel in a district.

\paragraph{Yield rules}
The logic to manage yield rules will be encapsulated in crossroads, which has
to ensure the respect of the street code.

\paragraph{Booking a park spot}
A traveller which is going out of a building with a vehicle will try to book
beforehand a spot in the destination building garage (which has limited
capacity), so that when she'll arrives at destination she will find room to
park her vehicle.

Even if this may not seem a concurrency problem at first glance, it is indeed:
two travellers may be leaving from each other's destination, and try to book a
spot in the garages they are leaving.
Therefore, if they both retain a lock on the garage to hold the vehicle they
are coming out with, they are exposed to a deadlock hazard.

We address this issue by making the garage implementation thread-safe, namely
having it be composed of three protected objects:

\begin{itemize}
  \item \textbf{Parked vehicles:} vehicles which are parked in the garage
    without anyone onboard
  \item \textbf{Leaving vehicles:} vehicles which are currently exiting the
    garage
  \item \textbf{Pending vehicles:} vehicles which are not yet arrived in the
    garage or that are currently booking a park spot
\end{itemize}

Thanks to this division, we are able to avoid holding a lock on the garage
object and access its state concurrently without blocking inside the critical
regions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TIME
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Solution to Time Problems}

In section \ref{sec:pa-time-problems} we point out some questions we made
ourselves about time management in our simulations; hereafter we provide
answers on how we designed the flow of time in our system.

\paragraph{How can we simulate road users proceeding (regarding to travelling
  speed)?}
Our system will be comprehensive of a scheduler, which executes actions:
active entities will implement a common interface through which the scheduler
is able to run them.

Actions are enqueued by using the package \texttt{Ada.Real\_Time} and one-shot
timers: when each timer expires, a callback will be responsible of pushing the
action on a queue consumed by a set of worker threads.

\paragraph{How can we simulate crossroads (regarding to road users' arrivals
  time)?}
Crossroads logic will be managed by means of an Ada Protected Object. By
carefully handling concurrent accesses to these objects, we aim to provide the
exact semantic for intersections between roads.

\paragraph{How long do people stay in facilities for? How much precise do these
  intervals have to be?}
Time spent in facilities is decided arbitrarily as a configuration parameter.
These time periods will have the best accuracy provided by the resolution
chosen for the scheduler.

\paragraph{How are semaphores going to be able to synchronize? Which of them
  decide how much time do they have to wait for?}
Semaphores will be active entities, and therefore their actions will be
periodically scheduled.

The period of a semaphore will be a configuration parameter.

\paragraph{When is it suitable to use logical clocks instead of local system
  clock?}
We will use the local system clock of the nodes so that we will be able to
have real concurrency between nodes (if an entity is scheduled for a given
time moment, it should not block waiting to be synchronized in order to be
executed), enabling better scalability for the whole system.
