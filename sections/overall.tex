\section{System architecture}
As we previously said, our system is a simulator whose computation spreads
across multiple nodes.

\subsection{Macro components}

In order to easily reason about the system, we thought it was reasonable to
divide it in four logical macro components.
An overall view of our architecture
is depicted in Figure \ref{fig:sd-sys-arch-overall}:

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5,keepaspectratio]
    {images/solution/overall-arch.eps}
  \caption{Overall system architecture}
  \label{fig:sd-sys-arch-overall}
\end{figure}

As we can see from Figure \ref{fig:sd-sys-arch-overall}, the system consists of:

\begin{itemize}
  \item \textbf{Backend} - composed of the \textbf{Application} and the
    \textbf{Middleware} layers;
  \item \textbf{(Message) Broker} - which is responsible to filter, format
    and eventually enrich the messages which flow between the other components.
    Please keep in mind that this component is \textit{not} RabbitMQ itself,
    but an architectural component we decided to put in our system;
  \item \textbf{Frontend} - composed of:
  \begin{itemize}
    \item \textbf{Application Server} - which is responsible of handling
      information generated by the backend and to serve it to the viewer;
    \item \textbf{Viewer} - which offers the streaming services to end users.
  \end{itemize}
\end{itemize}

We believe this architecture can scale in each of its parts: the backend and
the application server are loosely coupled. They communicate using a
publish-subscribe mechanism, so they do not know directly each other but their
communication is managed through a set of different queues.
The application server keeps very little information for
each connected user and is linked to a persistent separated component
which will eventually store set of specific messages
(if a persistent consumer is enabled).

We will try to make the backend transparent to the middleware and vice versa.
The middleware has to be unaware
of the specific domain of our application logic.
Thus, the application should expose an interface for the generic operations of
a computational node, like boot and shutdown.

The message broker contributes to the scalability of the system as well: if we
were to replicate application servers to cope with a rising amount of
sessions, we could instantiate more than one broker per city (actually, one
per application server connected to a specific city).
Also, these brokers provide a useful means to enrich the topic of the messages
by inspecting their content. Therefore, (probably) lighter versions of the
same incoming message, but with a more specific topic, will be sent out by the
broker towards to the application server.

Each one of these architectural macro components can be distributed as well: we
focused our efforts on distributing the backend over multiple computation nodes
by using a \textit{2D-wrap-around topology}.
We thought this is an interesting approach to distribute our system since it
fits perfectly the way we can divide a simulated city, besides the fact this is
a topology which scales well when it comes to distribute network traffic.

In particular, we think this topology fits our needs. Indeed, the
most frequent application-level actions are
represented by a traveller which moves from a district to an
adjacent one to continue its travel. Obviously this actions span over
multiple nodes.

Therefore, if adjacent backend nodes contain adjacent districts, we are able to
avoid a significant amount of unnecessary network traffic. In Figure
\ref{fig:sd-sys-arch-topology} we show a sample city in which each district
$D_i$ is a backend node, the edges starting from each district are the links
between backend nodes:

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5,keepaspectratio]
    {images/solution/topology.eps}
  \caption{Sample topology for our system}
  \label{fig:sd-sys-arch-topology}
\end{figure}


\subsection{Microservice architecture}

We further decoupled each macro component into a set of isolated services
which communicate by exchanging messages. The decoupling into micro isolated
services enables our system to scale horizontally. Indeed, each service is wrapped
into a container such that we can replicate it when needed. This is the major advantage
of this approach. The drawback consists in the complexity to manage a set of decoupled
services instead of a monolithic one. Due to this we need an external entity which
will have the responsibility to manage and monitor all the services: e.g., when a node crashes it should reschedule another one or reactivate it. The orchestrator will
manipulate the \textit{node} abstraction level, without knowing anything about what is inside each node. This is extremely important because it lets us to assign
a single responsibility to the orchestrator and clearly separate the services from
the orchestrator.


The Figure \ref{fig:sd-sys-arch-micro} represents how we have distributed
the components as microservices. However, we have not been able to decompose the
frontend macro component as we designed to do.

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5,keepaspectratio]
    {images/solution/microservices.eps}
  \caption{The microservice architecture of the city system}
  \label{fig:sd-sys-arch-micro}
\end{figure}


\subsection{Deployment}
In light of the above, we designed the deployment of our system. Even
if a single city simulation would be composed of all the blocks in Figure
\ref{fig:sd-sys-arch-micro}, it is not reasonable to instantiate all of them
each time a new simulation for a city is requested.
We instead propose a different approach: multiple users share the same frontend
(regardless of the fact they are consuming the same simulation) and all the
blocks from the message broker to the application are replicated for each city.
Finally, we identify the RabbitMQ broker as the Application Server endpoint for
the MessageBrokers of the different city instances.

Our proposed solution has a visual representation in Figure
\ref{fig:ovrl-deployment}, in which we used the following notation:

\begin{itemize}
  \item \textbf{City\_X:} instance of a city, which is composed of a backend,
    a MessageBroker and the RabbitMQ broker between them;
  \item \textbf{RabbitMQ to AS:} node which basically provides bidirectional
    communication between the cities and the frontend. Cities send events to
    the frontend, whereas the latter starts city instances by means of this
    broker;
  \item \textbf{Frontend:} Node which is composed of the ApplicationServer and
    the user client. It keeps track of which city simulations are currently
    running and serves live streaming services to end users.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[scale=0.4,keepaspectratio]
    {images/overall/deployment.eps}
  \caption{System deployment}
  \label{fig:ovrl-deployment}
\end{figure}
