\section{Conclusion}

% During this project we reason about different
% aspects of a concurrent and distributed system.


This project has been a long and deep journey into the software development life-cycle
using technologies which are the state-of-the-art in their respective fields.
In particular, we had the chance to experiment
with technologies which are mostly used by
niches, like Ada and Elixir.
Also, as students, it has been the largest project we developed during the MSc degree.
% (i.e., Ada and Elixir).
\\

We planned each stage of the project by defining the
types of team meetings and their frequency:
\begin{itemize}
	\item \textit{monthly meetings} : periodic meetings to synchronize on the
	project areas. Each meeting produces an agenda and a report
	(written during and after the meeting);
	\item \textit{exceptional meetings} : meetings planned
	for exceptional purposes.
	For example, to review an external meeting with the customer
	or to discuss important points about the project.
\end{itemize}

Firstly, we analyzed the domain and tested several technologies through
prototypes to choose the ones which best fit our needs.
Then, we reasoned and designed the distributed parts of the system.
After that, we designed the concurrent parts of the system focusing
on avoiding common concurrency problems (i.e. deadlocks, race conditions).
Then we implemented each single separated macro component
and finally we integrated
them together. The components' integration has been
the harshest period of the project.
Indeed, we experienced common realistic problems of
a distributed system such as network failures and language interoperability
problems. Also, trying to deploy the whole distributed system as a single unit
has been quite interesting, but not straightforward.

We have been to reach the goals we set ourselves at the beginning of this
project, despite it has been a cookie tougher than expected.
Indeed, our simulator works as expected and we had the chance to experiment
and see with our own eyes how different technologies work under the hood and
how they interact when brought
together to compose a quite complex application.
We recognize that a lot of feature have only be sketched and not fully
implemented. This is due to the fact that we focused on certain project aspects
rather than others.
We also had the chance to combine more than one academic project in order to
develop something more meaningful.

The main difficulties we encountered during the project are due to
``real-world'' problems: in fact, we wanted to approach this project seriously
from its very beginning, virtualizing the environment in which we build and
run the program and adopting clear rules for our development processes.
In fact, we wanted to avoid writing yet another toy project, which could have
resulted in just a meaningless homework.
Therefore, we are satisfied on the final outcome of this project, though we
have to recognize we have been through a lot of hardship which caused us to
focus more on certain aspects of the project.

% When we first started ACTS,
% we could have decided to use one single
% technology for the
% whole project, but then we wouldn't
% have realized how it is to be with high
% heterogeneous systems, which is an
% actual issue in the industry.

% \subsection{Technologies}

% As for the technology choice, we intend to provide a series of opinions ensued
% from our experience:

% \noindent\textbf{Ada} allows to write solid and reliable systems, but it is
% hard to develop a general-purpose application with it, for several reasons. Its
% learning curve is definitely steep and it is not easy to master Ada in order
% to apply common OOP design patterns or even to perform string processing or
% operations which are quite straightforward in other programming languages.
% Also, Ada lacks of a strong community support like other technologies do, and
% therefore sometimes it has been difficult to find a solution for easy
% problems. However, we have to recognize that Ada's strong typing and its
% concurrency model helped us in many occasions;

% \noindent\textbf{Elixir} turned out to be actually both productive, fast and
% reliable as claimed by its website. In fact, many of its features are very
% useful when reasoning about distribution, and we were able to develop both the
% middleware and the broker subsystems in a relatively short amounts of time.

% \noindent\textbf{RabbitMQ} and \textbf{Redis} were straightforward to use and
% configure.

% \noindent\textbf{Docker} certainly was handy for our needs. However, we had to
% automate ourselves a substantial part of the configuration procedures, because
% we wanted to achieve flexibility and different modes (development, production
% and test) for ACTS.

% \noindent\textbf{AngularJS 4} eased sensibly the development of our frontend.
% However, during the development of our system AngularJS 2 was effectively set
% aside by Google and we had to port our frontend to AngularJS 4 to continue
% enjoying a live and active community and to avoid using deprecated libraries.

% \subsection{Expectations and Actual Outcome}
