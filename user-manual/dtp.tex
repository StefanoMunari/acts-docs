
\section{Deployment environments}

\subsection{Brief information}

You can choose between three deployment environments:

\begin{itemize}
\item Development - \texttt{dev} or \texttt{d};
\item Testing - \texttt{test} or \texttt{t};
\item Production - \texttt{production} or \texttt{p}.
\end{itemize}

You can specify the chosen environment during the build step:

\begin{lstlisting}
./build.sh -s <services> -m <environment>
\end{lstlisting}

where the \texttt{-m} flag is used to choose the environment.


An example (production environment):

\begin{lstlisting}
./build.sh -s backend-mw-fe -m p
\end{lstlisting}

\texttt{backend-mw-fe} represents the whole system (the three macro-components).


\subsection{Detailed instructions}
Thanks to Docker, during the project we have been able to easily define several
deployment environments for ACTS. Indeed, from the very beginning we implemented a CI (Continuous Integration) server and hosted it
on AWS (Amazon Web Services) to automatically build and run our unit tests.
Thus, the Jenkins master node deployed the
system components in test mode inside Docker containers.
The test environment automatically compiles the project with the tests and
runs a specific set of tests specified manually by the developer or chosen automatically by
the CI server (e.g., the Jenkins master). The configuration of this mode has been quite simple
since we were testing only isolated components;
we just needed to instantiate a temporary
container to run a specific set of tests.


Instead, in the development environment we used containers in an unconventional
way. We started each container with a entrypoint which
only purpose was to keep the container up, thus enabling the developers to log into it.
Although a bit unorthodox, this approach has proved to be very effective.
Indeed, the developer was able to run the prototypes and the unit tests once
logged in, without requiring to install all the project dependencies on its
own system.


Production mode represents the system configuration which will be used by the final user. Thus, it is necessary
to test the system both automatically and manually before shifting to this deployment stage. For the sake of
simplicity, we did not define an Acceptance nor a Stage environment. However,
we recognize that a real project should be comprehensive of these
stages in its deployment pipeline in order to guarantee a higher level of
product quality to the final user (i.e., minimize the probability to deliver a
broken product).

